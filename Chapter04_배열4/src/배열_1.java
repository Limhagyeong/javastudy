/*
 * 1. 변수, 배열 => int, String
 *               ------------
 * 2. 요청 처리 => 연산자, 제어문 (메소드화)
 *              -------------
 *    연산자 : 산술연산자 (+,%)
 *           비교연산자  , 논리연산자, 대입연산자(+=)
 *    제어문 : if , if~else 
 *            for : 향상된 for => 출력 전용 
 *                  ------------------- 웹, JavaScript
 *                                         ----------
 *                                             |
 *                                           라이브러리
 *                                           forEach, map
 *                                           => VueJS, React, Redux
 *            while : 데이터베이스 연동 (오라클에서 데이터 읽기)
 *    --------------------------- 기본 과정
 * 3. 분리작업 => 관련된 내용을 묶어서 사용
 *    -----
 *     데이터 묶어서 사용
 *      = 배열
 *      = 클래스
 *     명령문 묶어서 => 입력 / 처리 / 출력 = 메소드
 *     ------------------------------------ + 
 *       => 객체지향프로그램 : 재사용 , 수정 , 기능 추가 ,  데이터 노츨 방지
 *                         ----   -------------    ---------- 캡슐화
 *                           |     다용성(오버라이딩,오버로딩)
 *                          변경해서 사용 => 상속 (is-a)
 *                          있는 그대로 사용 => 포함 (has-a)
 *    ----------------------------------------------------
 *    1) 객체지향 설계 => 인터페이스
 *    2) 비정상 종료를 방지 (오류를 사전에 처리) => 예외처리 
 *    3) 라이브러리 => 조립식 프로그램
 *       ------- 네트워크 , 데이터베이스 연동 
 *    
 * 배열  
 * --- 데이터 묶기 
 *  => 연속적으로 메모리 할당 => 인덱스 이용
 *  => ----- 동일한 메모리 크기
 *  =>       -------------- 동일한 데이터형 (단점)
 *  => 고정적이다 (크기를 선언하면 수정이 어렵다)
 *                          ----
 *                            |
 *                            큰 배열을 다시 만들어서 사용
 *     --------------- 보완 : 컬렉션 (***********)
 *  배열 사용
 *  ------
 *     1. 배열 선언
 *        데이터형[] 배열명; => 권장 사항
 *        --------(배열 데이터형)
 *        데이터형 배열명[]; => C언어 
 *     2. 초기값 부여
 *        ---------
 *        1) 명시적 초기화 => int, char
 *        --------------
 *           => int[] arr={1,2,3,4,5};
 *        2) 크롤링 초기화
 *        3) 파일
 *        -------------- String
 *        4) 입력 => int, char
 *           int[] arr = new int[5];
 *           arr[0]=(int)(Math.random()*100);
 *           arr[1]=scan.nextlnt();
 *           => 저장된 데이터가 많은 경우
 *              for => index이용
 *           
 *        5) 난수 => int, char
 *           ----------------- 형식, 순서
 *        
 *     3. 필요시에 수정
 *        arr[0] => 일반 변수와 동일
 *        arr[0]=100 => arr[0]=1000 ...
 *        => 배열 : 변수명이 동일 => 인덱스 번호 이용
 *                              --------
 *                               순차적 => for문 사용하기 쉬움
 *     4. 출력 => 검색
 *        ---
 *        for each=> 향상된 for : 간결하다, 속도가 빠르다 
 *        for(데이터형 변수명: 배열, 컬렉션)
 *            ------       ---------
 *               |
 *            배열에 저장되어있는 데이터형과 일치 혹은 더 커야함
 *            => 인덱스가 아닌 실제 데이터값을 하나씩 읽어온다
 *     5. 배열의 갯수 : 배열명.length
 *                   ----------- 갯수
 *     ---------------------------------
 *     6. 출력 시 항상 0번부터 출력하는 것은 아니다
 *        => 필요시 역순으로 출력할 수도 있음 (length-1)
 *           for(int i=arr.length-1;i>=0;i++)
 *     7. 배열의 범위를 초과하면 => ArraysIndexOutofBoundsException
 *         [1]
 *         --- 배열의 인덱스, 첨자
 *     8. 자동 초기화
 *       --------- new를 이용하면 메모리 할당시에 자동 초기화 된다
 *       int => 0
 *       double => 0.0
 *       boolean => false
 *       char => '\u0000' => null값 => 값은 있지만 주소가 없음
 *       모든 클래스는 null값 초기화된다
 *       
 *       int[] arr; ==> arr=null (주소 할당이 되지 않음) => 참조 변수
 *         => int[] arr = {1,2,3,4,5}
 *         => int[] arr=new int[5];
 *                  --- 0,0,0,0,0
 *       String s; => null
 *     9. 메모리 할당
 *       int[] arr=new int[100]; ==> 10개만 사용 / 90개는 남음 (고정헝) => 가변형: 컬렉션
 *       -----------
 *       
 *       arr                 실제 저장되는 위치 [heap]
 *                           arr[0]  arr[1] arr[2] => 무조건 순차적
 *       --------         --------------------------
 *        100                  0      0      0
 *       --------        |--------------------------
 *                      100
 *       ----------------------------------------------------
 *       
 */
import java.util.Scanner;
public class 배열_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
        // 변수 선언 => year, month => 입력
		int year,month;
		Scanner scan=new Scanner(System.in);
		System.out.print("년도 입력:");
		year=scan.nextInt();
		System.out.print("월 입력:");
		month=scan.nextInt();
	    // 처리 => 달력을 만들기 위한 처리 ==> 세부적 (메소드가 많을 수 있다)
		// => 1년 1월 1일 ~ 입력 년월까지의 => 총날수%7 => 요일 => 1일자에 대한 요일
		// 1. 전년도까지의 합
		int total=(year-1)*365
				  +(year-1)/4
				  -(year-1)/100
				  +(year-1)/400; // 윤년조건 
		
		// 2. 전월까지의 합
		int[] lastday= {
				31,28,31,30,31,30,
				31,31,30,31,30,31
		};
		// 문제 발생 ==> 2월 (윤년 => 29, 윤년X => 28)
		// 윤년 조건 => 프로그램에서 자주 등장 => 메소드를 만들어둠
		if((year%4==0 && year%100!=0)||(year%400==0))
		{
			// 윤년이라면 => 2024
			lastday[1]=29;
		}
		else
		{
			// 윤년이 아니라면
			lastday[1]=28;
		}
		
		//전달까지의 합
		for (int i=0;i<month-1;i++)
		{
			total+=lastday[i];
		}
		// 3. +1
		total++;
		// 요일구하기
		int week=total%7;
		/*
		 * char c=' ';
		 * switch(week)
		 * {
		 *    case=0;
		 *    c='일';
		 * } => 6번 넣어줘야하기때문에 아래 한줄로 끝냄
		 */
		char[] strweek= {'일','월','화','수','목','금','토'};
		
		// 달력 출력 ==> 메소드
//		System.out.println(year+"년도 "+month+"월 1일은 "+strweek[week]+"요일입니다");
		System.out.println(year+"년도 "+month+"월");
		System.out.println();
		for(int i=0;i<strweek.length;i++)
		{
			System.out.print(strweek[i]+"\t");
		} // 전체 요일 넣어줌
		System.out.println();
		for(int i=1;i<=lastday[month-1];i++) // 1~12까지
		{
			if(i==1)
			{
				for(int j=0;j<week;j++) // 1일에 맞는 요일부터 출력해라
				{
					System.out.print("\t");
				}
			}
			System.out.printf("%2d\t",i);
			week++; //
			if(week>6) // 토요일보다 커지면
			{
				week=0; // 일요일이 되고
				System.out.println(); // 한줄 띄어서 출력해라
			}
		}
		
	}

}







